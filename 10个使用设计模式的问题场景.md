### 项目环境

+ Eclipse平台
+ Java语言

### 项目介绍

选取生活或者编程中遇到的10个能够使用设计模式的问题场景,对各个问题场景进行介绍并用代码进行了实现.

### 1.使用单例模式的场景

##### 场景介绍

在生活中我们经常遇到一些资源在同一时间只能有一个人去使用的情况,如过独木桥的时候,如果独木桥非常细,每次只允许一个人经过,如果这个人还没有走到桥的另一头,则下一个人无法过桥。如果两个人同时上桥,桥就会塌掉,桥上的人都会掉河里面.

##### 场景分析

该场景中问题中不变的地方是独木桥这种资源本身的数量和承受能力,变化的是每次上桥的人数,并且每次上桥的人数的变化会导致独木桥这种资源可能的崩溃。像这种被多个使用者所使用时资源本身状态会发生变化并且要求变化的数据一致性的场景,可以考虑用单例模式.

##### 项目代码说明

+ 在SingleThreadedExecution文件夹下的noSingle包内模拟了**没有限制每次过桥人数**的场景
+ 在SingleThreadedExecution文件夹下的Single包内模拟了**限制每次过桥人数**的场景

##### 使用单例模式的原因

在上述场景中,桥扮演了一个共享资源的角色,过桥的人就是竞争共享资源的角色.该场景中共享资源是有可能被多个竞争者所使用的,因此我们可以考虑使用单例模式来限制竞争者对共享资源的使用. 抽象到程序中,即多线程模式下多个线程可能同时对某一字段进行修改,为保证多线程模式下数据的一致性和安全性,我们可以使用单例模式,采用加锁(使用synchronized关键字)来保证线程安全.

### 2.使用Balking模式的场景

##### 场景介绍

在生活中我们来到餐馆,举手示意服务员要点餐,这时候看到我们示意的服务员A拿着菜单向我们走来点菜,而另一位服务员B也看到我们示意,但是因为B同时也看到了A已经向我们走来,所以就没有再过来.

##### 场景分析

在这个场景中服务员B想要执行"向顾客走去并提供点餐服务"这个操作,但是因为看到了A已经提供了这个服务,所以他就没必要执行一样的操作,直接停止自己的操作返回,这种情况下就是使用了Balking模式.适用于Blaking模式的场景中需要有一个拥有被保护方法的被保护对象,其他对象访问这个对象的被保护方法时,要检验守护条件(如场景中的是否有服务员为顾客提供点餐服务),如果不满足守护条件,就立即返回,如果满足守护条件,就执行被保护方法中的操作.

##### 项目代码说明

+ Balking文件夹下Data类担任的角色就是被保护对象,Data类的save方法就是被保护方法,Data类中的changed字段为守护条件
+ Balking文件夹下的项目代码模拟了上述场景:ChangerThread线程和SaverThread线程都想要对同一个Data类对象执行更新Data类的save操作,在更新之前两个线程都对Data类的状态进行检查,看Data类当前内容(content)是否是处于被修改状态,如果是,则当前线程进行保存,如果不是,则跳过该操作.
+ 从项目运行结果来看,每次Data类的内容更新后,save操作都不会被重复执行.

### 3.使用生产者消费者模式的场景

##### 场景介绍

在糕点店,几位糕点师把制作好的蛋糕放在桌子上,之后顾客就可以购买或者吃掉桌子上的蛋糕.当桌子能放置的糕点数量有限时,糕点师要放置蛋糕必须等到桌子上出现空位,顾客要购买或者吃掉蛋糕的时候桌子上必须要有蛋糕,没有的话就必须等待.   



或者是我们去饭店吃饭的时候,饭店的餐桌位置有限,如果我们想要入座,餐桌位置必须有空余且已经被清理完毕,如果饭店服务员想要清理饭店位置,则必须等待顾客吃完之后才可以清理



##### 场景分析

在上述场景中我们可以看到主要登场的角色有三个,分别是生产者(如生产糕点的糕点师,能打扫腾空位置的饭店服务员)、消费者(如购买糕点的顾客,需要占用位置的饭点食客),和通道(如糕点店的桌子和饭店的餐桌位置).在这种场景中,生产者角色拥有产生数据的功能,消费者拥有消耗数据的功能,通道负责接收生产者产生的数据并保存,同时接受消费者的消费请求.这种看似简单的操作,**可能因为生产者和消费者两者处理速度的不同而引起问题,比如消费者想要获取数据,但是数据还没有生成,或者生产者想要交付数据,而消费者的状态还无法接受数据等**



**使用生产者和消费者模式,在生产者和消费者之间添加了一个"桥梁角色",即通道角色,即可消除生产者和消费者因处理速度差异带来的潜在问题**

##### 项目代码说明

+ 在Producer-Consumer文件夹下的类模拟了糕点店的场景
+ 通过运行结果可以看出来在应用了生产者-消费者模式后,多个线程之间可以无差错的协同进行

### 4.使用读写锁模式的场景

##### 场景介绍

在教室上课的时候老师一个人负责在黑板上板书,这时老师想擦掉板书再写新的内容,而学生们还没有看完板书,就请求老师先不要擦去板书,这时候老师就会等待大家看完后再擦掉板书更新内容..

多人合作做一个大项目的时候,可能出现两个人同时想对同一个文件进行更改操作,这时候如果允许两个人同时对这个文件进行操作就有可能两个人的更改不确定性的互相覆盖,而同时也要允许多个人同时查看同一个文件的..



##### 场景分析

+ 上述场景中出现的事物可以抽象出四个角色:读者、写者、共享资源、读写锁.
+ 共享资源是指读者和写者共享的资源.在共享资源内部提供不修改内部状态的操作(read)和修改内部状态的操作(write)
+ 读者角色对共享资源角色进行read操作
+ 写者角色对共享资源角色进行write操作
+ 读写锁角色提供了实现read操作和write操作时所需要的锁,这种锁可以被看做是一种管理机制,用来实现读者和写者进行安全的读写操作
+ 读写锁模式的使用保证了读操作和读操作可同时执行以及写操作和写操作、写操作和读操作之间的互斥.

##### 项目代码说明

+ 在Read-Write-Lock文件夹下的代码实现了多个线程对同一个资源进行读写操作的模拟
+ 从结果来看,运用读写锁模式保证了多个线程同时访问共享资源时贡献资源内部状态变化的一致性

### 5.使用委托者模式的场景

##### 场景介绍

+ 把自己点好的菜单交给饭店服务员,服务员接受到菜单后自己不做菜而是通知后厨按照菜单做饭,之后服务员继续去服务顾客

+ 在学校里经常委托同学帮忙取个快递,在同学接受后,自己忙自己的工作
+ 在做一个选课系统的时候,我们采用了C/S模式:服务器端线程一直监听端口信息,接受到客户端发送来的选课请求后,服务器端本身并不对选课请求做处理,而是把这个请求转发给一个内部类去处理,而服务器端继续去监听请求,实现了职能分离,职能单一原则

##### 场景分析

在上述场景中我们可以看到主要有这么几个角色:委托人、主机、助手

+ 委托人(Client):委托人角色会向主机角色发送请求,但是它不知道也并不一定关心主机角色是如何实现请求的
+ 主机(Host):主机角色受到委托人的请求后,会新创建一个任务或者提供一定的资源给助手,让助手来处理请求
+ 助手(Helper):助手角色为主机角色提供请求处理的功能

##### 项目代码说明

+ 在threadPerMessage包下模拟了上述场景

### 6.使用工作者模式的场景

##### 场景介绍

+ 在工作车间,工人们负责组装塑料模型。客户会把很多装有塑料模型的箱子带到工作车间来,然后摆放在桌子上。工人必须把客户送来的塑料模型一个一个的组装起来:他们先把桌子上的装有塑料模型的箱子取回,阅读了箱子中的说明书后开始组装。当一箱模型组装完成后,工人们会继续去取下一个箱子,当所有的模型全部完成后,工人们会等待新的模型送过来.
+ 在使用Swing编写GUI应用程序时,必须注意事件分发线程:在使用GUI应用程序的时候,我们点击按钮或者移动鼠标,GUI应用程序会根据我们的操作来进行相应的处理。Swing中,"点击按钮"或者"移动鼠标"等操作被看作是"事件"(用相应的Swing的类来表示),当点击按钮后,这些实例会被保存在Swing内部"事件队列"里,之后由事件分发线程从事件队列中取出一个事件进行处理,当处理终止后,它会来到事件队列里,取出下一个事件进行处理,然后如此反复,当事件队列中一个事件都没有的时候,事件分发线程会等待事件的到来
+ 在使用Java编写选课系统中,考虑到服务器的承压能力,需要对系统设置允许同时选课的人员数量(即服务器端能同时处理选课请求的线程数必须有限),通过在服务器端设置一个线程池,内部创建了一定数量的处理客户端选课请求的线程.

##### 场景分析

+ 在上述场景中主要出现的角色主要有:委托者、通信线路、工人、请求
+ 委托者(Client):Client角色创建表示工作请求的Request角色并且将其传递给Channel角色
+ 通信线路(Channel):Channel角色用来接收来自于Client角色的Request角色,并且将其传递给Worker角色
+ 工人(Worker):Worker角色从Channel角色中获取Request角色,并且进行工作。当一项工作完成后,它会继续获取另外的Request角色
+ 请求(Request):Request角色是表示工作的角色,Request角色中保存了进行工作所必须的信息

##### 与其他模式的比较

实际上我们可以看到工作者模式和生产者消费者模式、委托者模式、以及命令模式和保护等待模式有类似之处。前面我们提到过委托者模式,在委托者模式中,Host角色接受到Client发送的请求后,会以匿名方式(建立Helper类的实例)来处理请求,处理完之后就把Helper丢了,而在工作者模式中,Client发送请求后,Worker处理请求后不会被销毁,而是会不断的去接受新的Client发送的请求,并处理。**两种模式基本思想都是"如果可以将自己的工作交给其他人,那么自己就可以做下一项工作.",不同之处在于工作者模式是通过轮流的和反复的使用其他可以处理工作的人来提高效率,而委托者模式是每次委托后可能更换处理工作的人**.在两种模式进行选择的时候,要着重考虑**启动新的处理工作的人花费的时间**,如果启用新的处理工作的人花费的时间较少甚至可以忽略不计,那采用委托者模式也可行.



除此之外我们可以看到工作者模式和委托者模式的另一个区别是**工作者模式可以控制提供的服务的数量(即工人数量)**,分析工作者模式和委托者模式的适用场景可以发现,使用工作者模式的场景下,我们可以自由定义工人的数量,而委托者模式下只能是对于Client的每一次请求进行一次处理(可以看做是对于每一个任务只能找一个工人去处理).



和生产者消费者模式区分时,我们要考虑实际场景下的侧重点,**生产者和消费者模式更专注于product(也可以看作是request)的生产与消费,至于product被消费的时候如何处理,它不关心**

##### 项目代码说明

+ 在worker包下的项目代码模拟了上述场景

### 7.使用Future模式的场景

##### 场景介绍

+ 我们平时在网购的时候先在网上浏览商品,选中自己中意的商品后下单付款,之后系统会给我们一个商品码证明自己已经下单,等到快递把我们的商品邮寄过来后,我们可以根据商品码提取货物.
+ 假设我们还是去蛋糕店订制蛋糕,那么在我们下单后,店员会给我们一个提货单,并告知我们提取蛋糕的时间。到了规定的时间之后,我们拿着提货单去取蛋糕,我们就可以以提货单为凭借取走蛋糕

##### 场景分析

上述场景中出现的的角色主要有:请求者、主机、虚拟数据、真实数据、期货

+ 请求者(Client):Client角色向Host角色发出请求并且会立即收到请求的处理结果(返回值)--VirtualData角色
+ 主机(Host):Host角色会创建新的线程,并开始在新线程中创建RealData角色,同时它会把Future角色返回给Client角色
+ 虚拟数据(VirtualData):CirtualData角色是让Future角色具有一致性的角色
+ 真实数据(RealData):RealData角色是表示真实数据的角色,创建真实数据角色要花费很长的时间
+ 期货(Future):Future角色是RealData角色的提货单,由Host角色传递给Client角色,从程序行为上来看,对于Client角色来说,Future角色就是VirtualData角色.

**Future模式的核心在于异步调用**,传统事件处理流程上,在请求者发出一个需要服务器端长时间处理的请求后,客户端一直等待着,直到数据返回,随后进行其他业务,这种处理方式会给请求者一种服务器端相应速度很慢的感觉并且会浪费请求者的资源,这时候使用Future模式就可以提高效率了,服务程序不需要等待数据处理完成便立即返回给请求者伪造的数据(相当于情景中的商品的订单,但是不是实际的商品),请求者拿到这个返回结果后不着急处理,而是利用等待时间,调用其他的业务逻辑.

##### 与其他模式的比较

+ 与委托者模式相比,使用Future模式不仅能够保留委托者模式中'提高"程序响应性"这个优点,而且能够获得处理的结果.我们可以看到委托者模式中通过在方法中创建一个新的线程(即实现一个Helper实例对象)模拟实现了异步调用,但是这种情况下Java方法调用本身还是同步的,即使被调用的方法的处理没有全部终止,调用方的处理依然可以继续向前执行,这就是委托者模式模拟实现异步调用的意义,只不过在这种模式下无法获取处理结果,使用Futue模式来"稍后设置处理结果",从而操作了异步方法调用的"返回值"

+ 在工作者模式中,我们使用了将方法的调用和执行分开来,并在其他线程中处理的思想,而在Future模式中,我们可以把"准备方法的返回值"与"使用方法的返回值"分离开.**把伴随方法调用的一连串处理如同慢动作一样分解后,把各个处理(启动,执行,准备返回值,使用返回值)分配给各个线程,使用多线程进行操作**,这里也有分而并行治之的思想

##### 项目代码说明

+ 在future包内的代码模拟了上述场景

### 8.使用两段终止模式的场景

##### 场景介绍

+ 小孩子在玩玩具的时候经常会把玩具弄得满房间都是,晚上到了睡觉时间,妈妈就会让小孩子收拾好房间再睡觉,这时候小孩子就会开始打扫房间
+ 在Java选课系统的实现中,我们要考虑的一个问题就是当客户端选课结束退出选课系统或服务器端关闭选课系统或者是两者中某一端出现了故障的时候,如何在保证信息不丢失的情况下合理断开客户端和服务器端的网络连接。当客户端发送选课请求到服务器端后,如果客户端立马发送了一个关闭与服务器端连接的请求,那么由于服务器端采用了委托者模式,在多线程的情况下,有可能先处理断开与客户端连接的请求,这就导致即使服务器端处理了客户端的选课请求后,客户端也无法接受到服务器端处理选课请求的结果.甚至有可能服务器端在断开与客户端的连接后仍然向客户端发送选课请求,导致系统出现异常

##### 场景分析

在上述场景中出现的角色主要有:终止请求发出者、终止者

+ 终止请求发出者(TerminationRequester):TerminationRequester角色负责向Termination角色发出终止请求
+ 终止者(Termination):Termination角色负责接收终止请求,并实际执行终止处理

 在上述场景的描述中,场景中的终止请求发出者对终止者发出终止请求,他们都希望终止者能够安全的执行终止请求、必定可以执行终止处理且在终止请求者发出终止请求后能够尽快的终止处理.

两段终止模式能满足上述情境中对终止的三个要求.

+ 使用两段终止模式,即使接收到了终止请求,线程也不会理解终止.这就好比即使妈妈说要睡觉了,孩子也不能慌慌张张的打扫房间导致玩具坏掉一样
+ 使用两段终止模式,在终止者接受到终止请求后,会中断可以中断的终止请求者发送终止请求,要转入终止处理,这就像不能让玩具散落一地就去睡觉一样
+ 使用两段终止模式,会中断可以中断的休眠的事情,尽快进入终止处理.这就像如果被妈妈说了快收拾房间.就要尽快的收拾房间一样

##### 项目代码说明

+ 在twoPhaseTermination包下的项目代码模拟了上述过程

### 9.使用不变模式的场景

##### 场景介绍

+ Java.lang.String类用来表示字符串,String类中并没有修改字符串内容的方法,也就是说,String的实例所表示的字符串的内容绝对不会发生变化.正因为如此,String类中的方法不需要声明为synchronized.

+ 由于String的实例内部状态不会发生改变,所以无论String 实例被多少个线程访问都不需要执行线程的互斥处理,因此巧妙的利用这个特点,能够提高程序的性能

##### 场景分析

使用不变模式的场景中角色只有不可变角色,这个角色中的字段的值不可以修改,也不存在修改字段内容的方法,该角色的实例被成功创建后,状态就不会发生变化

##### 项目代码说明

+ 在immutable包下的项目代码模拟了上述场景

### 10.使用等待唤醒模式的场景

##### 场景介绍

当我们正在打游戏的时候,外卖突然到了,因为这时候是决定胜负的一波团战,所以我们先告诉外卖员等一会,等打玩游戏我们再去取外卖.

##### 场景分析

上述场景中出现的情况是如果我们现在去去外卖(执行操作)会造成问题(团战失败,游戏输了),那么就等一会再执行操作.

##### 项目代码说明

+ 在guardedSuspension包下的项目代码模拟了上述过程











