### 项目环境

+ Eclipse平台
+ Java语言

### 项目介绍

选取生活或者编程中遇到的10个能够使用设计模式的问题场景,对各个问题场景进行介绍并用代码进行了实现.

### 1.使用单例模式的场景

##### 场景介绍

在生活中我们经常遇到一些资源在同一时间只能有一个人去使用的情况,如过独木桥的时候,如果独木桥非常细,每次只允许一个人经过,如果这个人还没有走到桥的另一头,则下一个人无法过桥。如果两个人同时上桥,桥就会塌掉,桥上的人都会掉河里面.

##### 场景分析

该场景中问题中不变的地方是独木桥这种资源本身的数量和承受能力,变化的是每次上桥的人数,并且每次上桥的人数的变化会导致独木桥这种资源可能的崩溃。像这种被多个使用者所使用时资源本身状态会发生变化并且要求变化的数据一致性的场景,可以考虑用单例模式.

##### 项目代码说明

+ 在SingleThreadedExecution文件夹下的noSingle包内模拟了**没有限制每次过桥人数**的场景
+ 在SingleThreadedExecution文件夹下的Single包内模拟了**限制每次过桥人数**的场景

##### 使用单例模式的原因

在上述场景中,桥扮演了一个共享资源的角色,过桥的人就是竞争共享资源的角色.该场景中共享资源是有可能被多个竞争者所使用的,因此我们可以考虑使用单例模式来限制竞争者对共享资源的使用. 抽象到程序中,即多线程模式下多个线程可能同时对某一字段进行修改,为保证多线程模式下数据的一致性和安全性,我们可以使用单例模式,采用加锁(使用synchronized关键字)来保证线程安全.

### 2.使用Balking模式的场景

##### 场景介绍

在生活中我们来到餐馆,举手示意服务员要点餐,这时候看到我们示意的服务员A拿着菜单向我们走来点菜,而另一位服务员B也看到我们示意,但是因为B同时也看到了A已经向我们走来,所以就没有再过来.

##### 场景分析

在这个场景中服务员B想要执行"向顾客走去并提供点餐服务"这个操作,但是因为看到了A已经提供了这个服务,所以他就没必要执行一样的操作,直接停止自己的操作返回,这种情况下就是使用了Balking模式.适用于Blaking模式的场景中需要有一个拥有被保护方法的被保护对象,其他对象访问这个对象的被保护方法时,要检验守护条件(如场景中的是否有服务员为顾客提供点餐服务),如果不满足守护条件,就立即返回,如果满足守护条件,就执行被保护方法中的操作.

##### 项目代码说明

+ Balking文件夹下Data类担任的角色就是被保护对象,Data类的save方法就是被保护方法,Data类中的changed字段为守护条件
+ Balking文件夹下的项目代码模拟了上述场景:ChangerThread线程和SaverThread线程都想要对同一个Data类对象执行更新Data类的save操作,在更新之前两个线程都对Data类的状态进行检查,看Data类当前内容(content)是否是处于被修改状态,如果是,则当前线程进行保存,如果不是,则跳过该操作.
+ 从项目运行结果来看,每次Data类的内容更新后,save操作都不会被重复执行.

### 3.使用生产者消费者模式的场景

##### 场景介绍

在糕点店,几位糕点师把制作好的蛋糕放在桌子上,之后顾客就可以购买或者吃掉桌子上的蛋糕.当桌子能放置的糕点数量有限时,糕点师要放置蛋糕必须等到桌子上出现空位,顾客要购买或者吃掉蛋糕的时候桌子上必须要有蛋糕,没有的话就必须等待.   



或者是我们去饭店吃饭的时候,饭店的餐桌位置有限,如果我们想要入座,餐桌位置必须有空余且已经被清理完毕,如果饭店服务员想要清理饭店位置,则必须等待顾客吃完之后才可以清理



##### 场景分析

在上述场景中我们可以看到主要登场的角色有三个,分别是生产者(如生产糕点的糕点师,能打扫腾空位置的饭店服务员)、消费者(如购买糕点的顾客,需要占用位置的饭点食客),和通道(如糕点店的桌子和饭店的餐桌位置).在这种场景中,生产者角色拥有产生数据的功能,消费者拥有消耗数据的功能,通道负责接收生产者产生的数据并保存,同时接受消费者的消费请求.这种看似简单的操作,**可能因为生产者和消费者两者处理速度的不同而引起问题,比如消费者想要获取数据,但是数据还没有生成,或者生产者想要交付数据,而消费者的状态还无法接受数据等**



**使用生产者和消费者模式,在生产者和消费者之间添加了一个"桥梁角色",即通道角色,即可消除生产者和消费者因处理速度差异带来的潜在问题**

##### 项目代码说明

+ 在Producer-Consumer文件夹下的类模拟了糕点店的场景
+ 通过运行结果可以看出来在应用了生产者-消费者模式后,多个线程之间可以无差错的协同进行

### 4.使用读写锁模式的场景

##### 场景介绍

在教室上课的时候老师一个人负责在黑板上板书,这时老师想擦掉板书再写新的内容,而学生们还没有看完板书,就请求老师先不要擦去板书,这时候老师就会等待大家看完后再擦掉板书更新内容..

多人合作做一个大项目的时候,可能出现两个人同时想对同一个文件进行更改操作,这时候如果允许两个人同时对这个文件进行操作就有可能两个人的更改不确定性的互相覆盖,而同时也要允许多个人同时查看同一个文件的..



##### 场景分析

+ 上述场景中出现的事物可以抽象出四个角色:读者、写者、共享资源、读写锁.
+ 共享资源是指读者和写者共享的资源.在共享资源内部提供不修改内部状态的操作(read)和修改内部状态的操作(write)
+ 读者角色对共享资源角色进行read操作
+ 写者角色对共享资源角色进行write操作
+ 读写锁角色提供了实现read操作和write操作时所需要的锁,这种锁可以被看做是一种管理机制,用来实现读者和写者进行安全的读写操作
+ 读写锁模式的使用保证了读操作和读操作可同时执行以及写操作和写操作、写操作和读操作之间的互斥.

##### 项目代码说明

+ 在Read-Write-Lock文件夹下的代码实现了多个线程对同一个资源进行读写操作的模拟
+ 从结果来看,运用读写锁模式保证了多个线程同时访问共享资源时贡献资源内部状态变化的一致性

### 5.使用委托者模式的场景

##### 场景介绍

+ 把自己点好的菜单交给饭店服务员,服务员接受到菜单后自己不做菜而是通知后厨按照菜单做饭,之后服务员继续去服务顾客

+ 在学校里经常委托同学帮忙取个快递,在同学接受后,自己忙自己的工作
+ 在做一个选课系统的时候,我们采用了C/S模式:服务器端线程一直监听端口信息,接受到客户端发送来的选课请求后,服务器端本身并不对选课请求做处理,而是把这个请求转发给一个内部类去处理,而服务器端继续去监听请求,实现了职能分离,职能单一原则

##### 场景分析

在上述场景中我们可以看到主要有这么几个角色:委托人、主机、助手

+ 委托人(Client):委托人角色会向主机角色发送请求,但是它不知道也并不一定关心主机角色是如何实现请求的
+ 主机(Host):主机角色受到委托人的请求后,会新创建一个任务或者提供一定的资源给助手,让助手来处理请求
+ 助手(Helper):助手角色为主机角色提供请求处理的功能

##### 项目代码说明

+ 在threadPerMessage包下模拟了上述场景

### 6.工作者模式





